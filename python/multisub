#!/usr/bin/env python3
import argparse
import sys
import re

def parseArguments():
    parser = argparse.ArgumentParser(description='multisub - Perform regex replacement operations based on grep-output-like input files')
    parser.add_argument('input', help="File/input stream containing list of lines with pattern: <filepath><separator><lineno>[optional rest of line], typically obtained via grep (or structviz tool).", type=argparse.FileType("r"), nargs="?", default=sys.stdin)
    parser.add_argument('-p,--patterns', dest="patterns", required=False, type=str, nargs="+", help=r"Search patterns (first, third, ...) and their replacement (second, fourth, ...). List must have even length.",default=[])
    parser.add_argument('-s,--search', dest="searchPatterns", required=False, type=str, nargs="+", help=r"Specify only search patterns.",default=[])
    parser.add_argument('-d,--delete-patterns', dest="deletePatterns", required=False, type=str, nargs="+", help=r"Patterns to delete",default=[])
    parser.add_argument('-e,--erase-lines', dest="eraseLinePatterns", required=False, type=str, nargs="+", help=r"Erase whole lines that contain one of the specified patterns.",default=[])
    parser.add_argument('-I,--inplace', dest="inplace", action="store_true", help="Apply replacement action directly to original file(s) [default=False]")
    parser.add_argument('-a,--write-input-lines', dest="writeInputLines", required=False, action="store_true", help="Write lines as specified in the input file to the destination file(s). Has precedence over other modifications.",default=[])
    parser.add_argument('--min', type=int, default=-1, required=False, help=r"Minimum line number (inclusive) to consider [default=-1]")
    parser.add_argument('--max', type=int, default=sys.maxsize, required=False, help=r"Maximum line number (inclusive) to consider [default=sys.maxsize]")
    parser.add_argument('--separator', type=str, default=r":-", nargs="?", help=r"Characters regarded as separator between filepath and lineno [default=':-']")
    parser.add_argument('-v,--verbose', dest="verbose", action="store_true", help="Verbose output")
    parser.add_argument('-n,--show-only-changes', dest="noOutput", action="store_true", help="Dry run; show only changes do not generate any output (to stdout or orginal file)")
    parser.add_argument('--nop',dest="noOp", action="store_true", help="Do nothing at all.")
    group_postprocess = parser.add_argument_group("Post-process replacements/search results")
    # post-procesing
    group_postprocess.add_argument('-w,--wrap-in-ifelse', dest="wrapInIf", default="", nargs="?", help="Wrap modified and original line in '#if<expression> <modified> #else <original> #endif' construct ")
    group_postprocess.add_argument('-i,--case-insensitive', dest="ignoreCase", action="store_true", help="Ignore case when searching for patterns [default=False]")
    group_postprocess.add_argument('-l,--lower', dest="lower", action="store_true", help="Convert ALL replacements/search results to lower case")
    group_postprocess.add_argument('-u,--upper', dest="upper", action="store_true", help="Convert ALL replacements/search results to upper case")
    group_postprocess.add_argument('-C,--camel-case', dest="camelCase", action="store_true", help="Convert ALL replacements/search results to 'camel case'.")
    group_postprocess.add_argument('-U,--underscores', dest="underscores", action="store_true", help="Convert ALL replacements/search results to 'underscore case'.")
    # defaults
    parser.set_defaults(ignoreCase=False,verbose=False,inplace=False,noOutput=False,writeInputLines=False,noOp=False,\
            camelCase=False,underscores=False)
    return parser.parse_args()

args = parseArguments()
if args.noOp:
    sys.exit()

if args.lower and args.upper:
    print("ERROR: please specify only one of upper ('-u') and lower ('-l'). ABORT",file=sys.stderr)
if args.camelCase and args.underscores:
    print("ERROR: please specify only one of underscores ('-U') and camel case ('-C'). ABORT",file=sys.stderr)
# parsing
flag = re.IGNORECASE if args.ignoreCase else 0
if not args.writeInputLines and not len(args.patterns) and not len(args.deletePatterns) and\
    not len(args.eraseLinePatterns) and not len(args.searchPatterns):
   print("ERROR: please specify either search patterns ('-s'), replace patterns ('-p'), delete patterns ('-d'), erase line patterns ('-e') or the '-a' switch. ABORT",file=sys.stderr)
   sys.exit(2)
if len(args.patterns) % 2 > 0:
   print("ERROR: list of search and replace patterns is not even. ABORT",file=sys.stderr)
   sys.exit(2)
for pattern in args.deletePatterns:
   args.patterns.append(pattern)
   args.patterns.append("")
for pattern in args.searchPatterns:
   args.patterns.append("("+pattern+")")
   args.patterns.append(r"\1")

# convert input into convenient format
# we want to open files only once.
locations = {}
       
splitPattern = re.compile(r"([{0}][ \t]*[0-9]+[ \t]*[{0}])".format(args.separator), flag)
for line in args.input.readlines():
    parts = splitPattern.split(line, 1)
    if len(parts)==3:
       filepath = parts[0].strip()
       lineno   = int(parts[1].strip(args.separator+" \t"))
       if lineno >= args.min and lineno <= args.max:
           text     = parts[2]
           if args.verbose:
              print("INFO: found filepath '{0}' and line number '{1}'.".format(filepath,lineno),file=sys.stderr)
           if not filepath in locations:
               locations[filepath] = []
           locations[filepath].append( (lineno,text.rstrip("\n")) )
    else:
       print("WARNING: input line '{0}' is not in format '<filepath><separator><lineno><separator>[optional rest of line]'. Is ignored.".format(line),file=sys.stderr)

# no go through the lines and replace all search patterns by the replacement pattern in the specified lines
for filepath,entries in locations.items():
    outputlines = []
    with open(filepath,"r") as target:
        for lineno, line in enumerate(target.readlines()):
            modLine = line.rstrip("\n")
            entry = next((entry for entry in entries if lineno+1 == entry[0]),None)
            if entry:
                # apply
                if args.writeInputLines:
                    if (args.verbose or args.noOutput) and entry[1] != modLine:
                       print("INFO: {0}:{1}: replace '{3}' -> '{2}'".format(filepath,lineno+1,entry[1],modLine),file=sys.stderr)
                    modLine = entry[1]
                # erase lines
                eraseLine = False
                for pattern in args.eraseLinePatterns:
                    pEraseLine = re.compile(r"{0}".format(pattern))
                    if pEraseLine.search(line):
                        if (args.verbose or args.noOutput):
                            print("INFO: {0}:{1}: erase line '{2}'".format(filepath,lineno+1,modLine),file=sys.stderr)
                        eraseLine = True
                        break
                # change line content if line must not be deleted
                if not eraseLine:
                    for i in range(0,int(len(args.patterns)/2)):
                        prevModLine = modLine
                        if args.lower or args.upper or args.underscores or args.camelCase:
                            def replaceAndChangeCase_(m):
                                """:note: callback is only applied to matching string."""
                                result = re.sub(pattern = r"{0}".format(args.patterns[2*i]),\
                                                repl    = r"{0}".format(args.patterns[2*i+1]),\
                                                string  = m.group(0),\
                                                count   = 0, flags = flag) # 0 - replace all matches
                                # camel case / underscores
                                if args.camelCase:
                                    parts  = [p for p in result.split("_") if len(p)]
                                    result = ""
                                    for j,part in enumerate(parts):
                                        if j == 0:
                                            result += parts[0].lower()
                                        else:
                                            result += part[0].upper()
                                            if len(part[1:]):
                                                result += part[1:].lower()
                                elif args.underscores:
                                    parts1 = re.split(r"([A-Z][a-z0-9]+|[A-Z][A-Z]+)",result)
                                    parts  = [p for p in parts1 if len(p)]
                                    result = ""
                                    for j,s in enumerate(parts):
                                        if s.isupper():
                                            if j != len(parts)-1:
                                                result += s[:-1] + "_" + s[-1]
                                            else:
                                                result += s
                                        else:
                                            result += s
                                            if j != len(parts)-1:
                                                result += "_"
                                # upper / lower
                                if args.lower:
                                    return result.lower()
                                elif args.upper:
                                    return result.upper()
                                else:
                                    return result
                            modLine = re.sub(pattern = r"{0}".format(args.patterns[2*i]),\
                                             repl    = replaceAndChangeCase_,\
                                             string  = modLine,\
                                             count   = 0, flags = flag) # 0 - replace all matches
                        else:
                            modLine = re.sub(pattern = r"{0}".format(args.patterns[2*i]),\
                                             repl    = r"{0}".format(args.patterns[2*i+1]),\
                                             string  = modLine,\
                                             count   = 0, flags = flag) # 0 - replace all matches
                        if (args.verbose or args.noOutput) and prevModLine != modLine:
                            print("INFO: {0}:{1}: replace '{2}' -> '{3}'".format(filepath,lineno+1,prevModLine,modLine),file=sys.stderr)

                    newlines = []
                    if len(args.wrapInIf):
                        newlines.append("#if{}\n".format(args.wrapInIf))
                    if modLine != "":
                        newlines += ["{0}\n".format(el) for el in modLine.split("\n")]
                    if len(args.wrapInIf):
                        newlines.append("#else\n")
                        newlines.append(line)
                        newlines.append("#endif\n")
                        if args.verbose or args.noOutput:
                             print("INFO: {0}:{1}: replace '{2}' -> '{3}'".format(filepath,lineno,prevModLine,"".join(newlines)),file=sys.stderr)
                    outputlines += newlines 
            else:
                outputlines.append(line)
    if len(outputlines):
        outputlines[-1] = outputlines[-1].rstrip("\n")
    if not args.noOutput:
        if args.inplace:
            if args.verbose:
                print("INFO: directly apply changes to original file '{0}'".format(filepath),file=sys.stderr)
            with open(filepath,"w") as target:
                target.writelines(outputlines)
        else: 
            print("".join(outputlines))
